[{"source":"public/brilliantexport/problems/../problems/1-in-5-americans-2/1-in-5-americans-2.html","category":"Computer Science","level":5,"title":"1 in 5 Americans","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"In \"},{\"type\":\"text\",\"text\":\"this video\",\"marks\":[{\"attrs\":{\"href\":\"\",\"target\":\"_blank\"},\"type\":\"link\"}]},{\"type\":\"text\",\"text\":\", Michael Aranda states that \\\"one in 5 Americans either has had bed bugs or knows someone who has.\\\"  Assume the following about the population of USA:\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"bulletList\",\"content\":[{\"type\":\"listItem\",\"content\":[{\"type\":\"text\",\"text\":\"There are 326,000,000 people in USA.\"}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"text\",\"text\":\"Each person is equally likely to be infected by bed bugs, and whether someone is infected is independent from whether another person is infected.\"}]},{\"type\":\"listItem\",\"content\":[{\"type\":\"text\",\"text\":\"Number the people from 0 to 325,999,999. Person \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"x\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" knows person \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"y\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" if and only if \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"x \\\\equiv y+k \\\\pmod{326,000,000}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" for some \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"k \\\\in [-250, 250]\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". That is, each person knows all people whose difference in numbers is at most 250, looping between 0 and 325,999,999. As an example, person number 500 knows all people whose number is in the set \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\{250, 251, 252, \\\\ldots, 750\\\\}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", and person number 0 knows all people whose number is in the set \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\{325999750, 325999751, \\\\ldots, 325999759, 0, 1, 2, \\\\ldots, 250\\\\}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"If the expected number of people infected with bed bugs is \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"N\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", find \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"25 \\\\lfloor \\\\frac{N-1}{25} \\\\rfloor\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Hint:\",\"marks\":[{\"type\":\"bold\"}]},{\"type\":\"text\",\"text\":\" The answer is between 100,000 and 200,000.\"}]}]}","answers":[{"correct":true,"text":"145150"}],"author":{"profile":"https://brilliant.org/profile/trevor-t668xm/","name":"Trevor Arashiro","age":22,"location":"USA"},"discussion":[{"author":{"avatar":"../../brioche/avatars-2/resized/45/82acd2b6fa449039fbe1b5ab9bc152f2.dc3191e62b-KiNb8v4MQ7.jpg?width=45","profile":"https://brilliant.org/profile/ivan-z1iujk/","name":"Ivan Koswara"},"date":"July 31, 2017, 3:04 a.m.","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                \\n                                \\n                                \\n                                    \\n                                        \"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Let the probability of having bed bugs be \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". Since 1 in 5 people know someone with bed bugs (which may be themself), 4 in 5 doesn't. Assuming having bed bugs is independent between people, the probability that someone doesn't know anyone with bed bugs is simply \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"(1-p)^{501}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". This must be equal to \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"0.8\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\"; by Wolfram Alpha, we obtain \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"p \\\\approx 0.0004452971\\\\ldots\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". The expected number of people with bed bugs is then \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"326000000 \\\\cdot p \\\\approx 145166.8662\\\\ldots\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", which rounds to \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\boxed{145150}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n                                    \\n                                \\n                            \"}]}","reactions":[4,0,0,0],"comments":[{"id":"268935","level":0,"replies":[{"id":"269008","level":1,"replies":[],"author":{"profile":"https://brilliant.org/profile/ivan-z1iujk/","name":"Ivan Koswara"},"date":"- 3 years, 10 months ago","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                        \\n\\n                                        \"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                            \\n\\n                                            \\n                                            This method works as long as each person knows exactly 501 people (which may include themself). And of course, you can generalize it so each person knows the same constant number of people. The reason it works is because each person is infected independently from another. If infection is not independent (e.g. infection is more likely in rural areas), or if the numbers of known acquaintances are different among people (e.g. more people know each other in office than in farms), then the solution doesn't work and indeed you might need to use simulation.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"horizontalRule\"},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Let's say \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"B_n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is the event that person \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is infected, and \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"K_n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is the event that person \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" knows anyone that's infected (which may be themself). In other words, if \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"S_n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is the set of people that \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" knows, then \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"K_n = \\\\bigcup_{i \\\\in S_n} B_i\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". Then by De Morgan's laws, \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\overline{K_n} = \\\\bigcap_{i \\\\in S_n} \\\\overline{B_i}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", so\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\displaystyle P( \\\\overline{K_n} ) = P \\\\left( \\\\bigcap_{i \\\\in S_n} \\\\overline{B_i} \\\\right) \"}],\"attrs\":{\"inline\":false}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"But since we assumed \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"B_p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\"'s are all independent, we have\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\displaystyle P( \\\\overline{K_n} ) = \\\\prod_{i \\\\in S_n} P( \\\\overline{B_i} ) \"}],\"attrs\":{\"inline\":false}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Finally, just plug in \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"P(\\\\overline{K_n}) = 1 - P(K_n) = 1 - \\\\frac{1}{5} = \\\\frac{4}{5}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". Call \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"P(B_i) = p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", then \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"P(\\\\overline{B_i}) = 1 - P(B_i) = 1-p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". Since \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"|S_n| = 501\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", the RHS becomes \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"(1-p)^{501}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". And of course, by linearity of expectation, \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"N\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is simply \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"326000000 \\\\cdot p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", so once we have \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"p\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", we have \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"N\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\\n\\n                                        \"}]},{\"type\":\"text\",\"text\":\"\\n\\n                                        \\n                                            \\n                                        \\n\\n                                        \\n\\n                                        \\n    \\n\\n    \\n\\n\\n                                    \"}]}"}],"author":{"profile":"https://brilliant.org/profile/trevor-t668xm/","name":"Trevor Arashiro"},"date":"- 3 years, 10 months ago","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                        \\n\\n                                        \"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                            \\n\\n                                            \\n                                            Hmm, I'm a little skeptical of this solution.  How did you know that this method would work for the given constraint that every person \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" knows everyone from \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n-250\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" to \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"n+250\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\"?  If I had given a different construction, the number of people infected does change.\\n\\n                                        \"}]},{\"type\":\"text\",\"text\":\"\\n\\n                                        \\n                                            \\n                                        \\n\\n                                        \\n\\n                                        \\n    \\n\\n    \\n\\n\\n                                    \"}]}"}]},{"author":{"avatar":"../../brioche/avatars-2/resized/45/21df9575b5ae6152b965c65a400a7835.21df9575b5ae6152b965c65a400a7835.jpg?width=45","profile":"https://brilliant.org/profile/trevor-t668xm/","name":"Trevor Arashiro"},"date":"July 7, 2017, 8:44 p.m.","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                \\n                                \\n                                \\n                                    \\n                                        \"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"The full code is posted below.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"If your computer can handle it, you could make an array with 326000000 elements and  generate N random numbers and see how many people know the infected.  However, this method was incredibly slow for me (took 20 mins per simulation).  Here is an alternative method that takes 0.1 seconds per simulation (on CS50).\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"1) generate an array (call it bugArray) of N random numbers, quick sort the array.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"2) for all elements in bugArray check bugArray[i]=bugArray[i + 1]\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Note: we could just generate random numbers to replace the duplicate elements and then insertion sort the new bugArray, but that actually takes a while.  Steps 3-6 are only to speed up this process  sort.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"3) for each i where step two is true, set duplicatePlaces[k] = i and set duplicateValues[k]= random number() mod 326000000.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"4) quick sort duplicateValues\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"5) insert, in order, each element duplicateValues[k] into bugArray[duplucatePlaces[k]].\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"6) insertion sort the new bugArray.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"7) repeat steps 2-6 until there are no duplicates\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Here comes a little math.  Remember, bugsArray[2]=10 means that person number 10 has bedbugs and that subject has the 3rd smallest number (since arrays start at 0).  For simplicities sake, assume the population of America is 35, 7 people are infected, and each person p knows the 4 people whose numbers are Between p+2 and p-2.  If someone knows more than one person with bed bugs, that person only increases the count by 1.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"bugArray[0] = 1; bugArray[1]= 7: bugArray[2]=9; bugArray[7]=15; bugArray[4]=19; bugArray[5]=25; bugArray[6]=30.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"If a 1 represents someone who has bed bugs or knows someone else with bed bugs, but not both, and a 2 represents an overlap (someone who knows two or more people with bed bugs or has bed bugs and knows someone else with bed bugs), then the subjects, in order, would look like this.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"|1-------|7-|9------|15--|19------|25---|30\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"11101122211011112111101111111111011 < (these last two 1's come from the first infected person).\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"The total number of people who have bed bugs or know someone who has bedbugs is 31.  We get this by multiplying the number of infected people by 5 and subtracting the number of duplicates.  5*7-4=31.\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"If two infected people's numbers are more than 4 apart there will be no over lap between the two.  However, if the difference is less than that, we must subtract the number of overlaps. \"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"I'll leave it as an exercise to the reader to prove that the total number of people who have bed bugs or know someone with bed bugs is given by (this does not include the last element of the bugArray, a couple rules must be added for that one).\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{total}=\\\\displaystyle \\\\sum_{i=0}^{\\\\text{number of infected people-1}} \\\\left\\\\{ \\\\begin{array}{c}\\\\text{numKnown}+1, & \\\\text{bugArray[}(i+1)\\\\text{]}-\\\\text{for bugArray[i]}>\\\\text{numKnown}\\\\\\\\\\n\\\\text{bugArray[}(i+1)\\\\text{]}-\\\\text{bugArray[i]}, & \\\\text{for bugArray[i]}<=\\\\text{numKnown}\\n\\\\end{array} \\\\right\\\\}\"}],\"attrs\":{\"inline\":false}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Here, numKnown means the number of people each subjects knows (in the example above, numKnown=4 and in the original problem, numKnown=500).\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Hint: shift all the values in the example above 2 right so they become\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"|1-------|7-|9------|15--|19------|25---|30\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"11111011222110111121111011111111110 < (these last two 1's come from the first infected person).\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"After using the above formula, and running many simulations, one can expect to find an answer between 145162 and 145173 infected people. The floor function in the problem causes all answers between 145150 and 145174 to be counted correct. \"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"codeBlock\",\"content\":[{\"type\":\"text\",\"text\":\"  1\\n  2\\n  3\\n  4\\n  5\\n  6\\n  7\\n  8\\n  9\\n 10\\n 11\\n 12\\n 13\\n 14\\n 15\\n 16\\n 17\\n 18\\n 19\\n 20\\n 21\\n 22\\n 23\\n 24\\n 25\\n 26\\n 27\\n 28\\n 29\\n 30\\n 31\\n 32\\n 33\\n 34\\n 35\\n 36\\n 37\\n 38\\n 39\\n 40\\n 41\\n 42\\n 43\\n 44\\n 45\\n 46\\n 47\\n 48\\n 49\\n 50\\n 51\\n 52\\n 53\\n 54\\n 55\\n 56\\n 57\\n 58\\n 59\\n 60\\n 61\\n 62\\n 63\\n 64\\n 65\\n 66\\n 67\\n 68\\n 69\\n 70\\n 71\\n 72\\n 73\\n 74\\n 75\\n 76\\n 77\\n 78\\n 79\\n 80\\n 81\\n 82\\n 83\\n 84\\n 85\\n 86\\n 87\\n 88\\n 89\\n 90\\n 91\\n 92\\n 93\\n 94\\n 95\\n 96\\n 97\\n 98\\n 99\\n100\\n101\\n102\\n103\\n104\\n105\\n106\\n107\\n108\\n109\\n110\\n111\\n112\\n113\\n114\\n115\\n116\\n117\\n118\\n119\\n120\\n121\\n122\\n123\\n124\\n125\\n126\\n127\\n128\\n129\\n130\\n131\\n132\\n133\\n134\\n135\\n136\\n137\\n138\\n139\\n140\\n141\\n142\\n143\\n144\\n145\\n146\\n147\\n148\\n149\\n150\\n151\\n152\\n153\\n154\\n155\\n156\\n157\\n158\\n159\\n160\\n161\\n162\\n163\\n164\\n165\\n166\\n167\\n168\\n169\\n170\\n171\\n172\\n173\\n174\\n175\\n176\\n177\\n178\\n179\\n180\\n181\\n182\\n183\\n184\\n185\\n186\\n187\\n188\\n189\\n190\\n191\\n192\\n193\\n194\\n195\\n196\\n197\\n198\\n199\\n200\\n201\\n202\\n203\\n204\\n205\\n206\\n207\\n208\\n209\\n210\\n211\\n212\\n213\\n214\\n215\\n216\\n217\\n218\\n219\\n220\\n221\\n222\\n223\\n224\\n225\\n226\\n227\\n228\\n229\\n230\\n231\\n232\\n233\\n234\\n235\\n236\\n237\\n238\\n239\\n240\\n241\\n242\\n243\\n244\\n245\\n246\\n247\\n248\\n249\\n250\\n251\\n252\\n253\\n254\\n255\\n256\\n257\\n258\\n259\\n260\\n261\\n262\\n263\\n264\\n265\\n266\\n267\\n268\\n269\\n270\\n271\\n272\\n273\\n274\\n275\\n276\\n277\\n278\\n279\\n280\\n281\\n282\\n283\\n284\\n285\\n286\\n287\\n288\\n289\\n290\\n291\\n292\\n293\\n294\\n295\\n296\\n297\\n298\\n299\\n300\\n301\\n302\\n303\\n304\\n305\\n306\\n307\\n308\\n309\\n310\\n311\\n312\\n313\\n314\\n315\\n316\\n317\\n318\\n319\\n320\\n321\\n322\\n323\\n324\\n325\\n326#include <stdio.h>\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <cs50.h>\\n#include <math.h>\\n#include <time.h>\\n#include <string.h>\\n#define population 326000000\\n#define bugs 145173\\n#define numKnown 500\\n#define trials 600\\n\\n// list of element number of every infected person\\nint subjList[bugs];\\n// array to be sorted and first few elements added to subjList\\nint duplicateArray[500];\\n// keeps track of where the added numbers are\\nint missingSpots[1000];\\n\\nvoid printline(int count) {\\n   int i;\\n\\n   for(i = 0;i <count-1;i++) {\\n      printf(\\\"=\\\");\\n   }\\n\\n   printf(\\\"=\\\\n\\\");\\n}\\n//------------------------------------------------------------------------\\nvoid display() {\\n    int i;\\n    printf(\\\"[\\\");\\n    // navigate through all items \\n    for(i = 0;i<50;i++) {\\n        printf(\\\"%d \\\", subjList[i]);\\n        if (i%11 == 0) {\\n            printf(\\\"\\\\n\\\");\\n        }\\n    }\\n   printf(\\\"]\\\\n\\\");\\n}\\n\\nvoid swap(int num1, int num2) {\\n   int temp = subjList[num1];\\n   subjList[num1] = subjList[num2];\\n   subjList[num2] = temp;\\n}\\n\\nint partition(int left, int right, int pivot) {\\n   int leftPointer = left - 1;\\n   int rightPointer = right;\\n\\n   while(true) {\\n      while(subjList[++leftPointer] < pivot) {\\n         //do nothing\\n      }\\n\\n      while(rightPointer > 0 && subjList[--rightPointer] > pivot) {\\n         //do nothing\\n      }\\n\\n      if(leftPointer >= rightPointer) {\\n         break;\\n      } else {\\n        swap(leftPointer,rightPointer);\\n      }\\n   }\\n   swap(leftPointer,right);\\n   return leftPointer;\\n}\\n\\nvoid quickSort(int left, int right) {\\n   if(right-left <= 0) {\\n      return;   \\n   } else {\\n      int pivot = subjList[right];\\n      int partitionPoint = partition(left, right, pivot);\\n      quickSort(left,partitionPoint-1);\\n      quickSort(partitionPoint+1,right);\\n   }        \\n}\\n//------------------------------------------------------------------------------\\n\\nvoid swap2(int num1, int num2) {\\n   int temp = duplicateArray[num1];\\n   duplicateArray[num1] = duplicateArray[num2];\\n   duplicateArray[num2] = temp;\\n}\\n\\nint partition2(int left, int right, int pivot) {\\n   int leftPointer = left - 1;\\n   int rightPointer = right;\\n\\n   while(true) {\\n      while(duplicateArray[++leftPointer] < pivot) {\\n         //do nothing\\n      }\\n\\n      while(rightPointer > 0 && duplicateArray[--rightPointer] > pivot) {\\n         //do nothing\\n      }\\n\\n      if(leftPointer >= rightPointer) {\\n         break;\\n      } else {\\n        swap2(leftPointer,rightPointer);\\n      }\\n   }\\n   swap2(leftPointer,right);\\n   return leftPointer;\\n}\\n\\nvoid quickSort2(int left, int right) {\\n   if(right-left <= 0) {\\n      return;   \\n   } else {\\n      int pivot = duplicateArray[right];\\n      int partitionPoint = partition2(left, right, pivot);\\n      quickSort2(left,partitionPoint-1);\\n      quickSort2(partitionPoint+1,right);\\n   }        \\n}\\n\\n//---------------------------------------------------------------------------------------------\\n\\nvoid sortTop(int totalDuplicates) {\\n    int move = 0;\\n    // dont need to check if element was inserted into last place of subjArray cuz last element there is never deleted\\n    while (true) {\\n        move = 0;\\n        // stop trying to sort if we have moved the new number to the last (or unlikely case, first) place of subjArray\\n        if (missingSpots[totalDuplicates - 1] == bugs - 1 || missingSpots[totalDuplicates - 1] == 0) {\\n            return;\\n        } else if (subjList[missingSpots[totalDuplicates - 1]] > subjList[missingSpots[totalDuplicates - 1] + 1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(missingSpots[totalDuplicates - 1], missingSpots[totalDuplicates - 1] + 1);\\n            missingSpots[totalDuplicates - 1] += 1;\\n            move = 1;\\n        } else if (subjList[missingSpots[totalDuplicates - 1]] < subjList[missingSpots[totalDuplicates - 1] - 1]) {\\n            swap(missingSpots[totalDuplicates - 1], missingSpots[totalDuplicates - 1] - 1);\\n            missingSpots[totalDuplicates - 1] -= 1;\\n            move = 1;\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\nvoid sortBottom() {\\n    int move = 0;\\n    if (missingSpots[0] == 0) {\\n        if (subjList[0] > subjList[1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(0, 1);\\n            // moves the place of the thing in the missing spots array cuz we just moved it one in the master array\\n            missingSpots[0] += 1;\\n            move = 1;\\n        }\\n    }\\n    while (true) {\\n        move = 0;\\n        // stop trying to sort if we have moved the new number to the last place of subjArray\\n        if (missingSpots[0] == 0) {\\n            return;\\n        } else if (subjList[missingSpots[0]] > subjList[missingSpots[0] + 1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(missingSpots[0], missingSpots[0] + 1);\\n            missingSpots[0] += 1;\\n            move = 1;\\n        } else if (subjList[missingSpots[0]] < subjList[missingSpots[0] - 1]) {\\n            swap(missingSpots[0], missingSpots[0] - 1);\\n            missingSpots[0] -= 1;\\n            move = 1;\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\n// if two numbers are inserted next to eachother, this method still works\\nvoid modifiedBubbleSort(int totalDuplicates) {\\n    int move = 0;\\n    // dont need to check if element was inserted into last place of subjArray cuz last element there is never deleted\\n    while (true) {\\n        move = 0;\\n        for (int n = 1; n < totalDuplicates - 1; n++) {\\n            // stop trying to sort if we have moved the new number to the last (or unlikely case, first) place of subjArray\\n            if (missingSpots[n] == bugs - 1 || missingSpots[n] == 0) {\\n                return;\\n            } else if (subjList[missingSpots[n]] > subjList[missingSpots[n] + 1]) {\\n                // swap the place in the array that has these two numbers because they're in the wrong order\\n                swap(missingSpots[n], missingSpots[n] + 1);\\n                missingSpots[n] += 1;\\n                move = 1;\\n            } else if (subjList[missingSpots[n]] < subjList[missingSpots[n] - 1]) {\\n                swap(missingSpots[n], missingSpots[n] - 1);\\n                missingSpots[n] -= 1;\\n                move = 1;\\n            }\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\n\\n// checks for duplicates within the master list, replaces them with other random numbers and re-sorts\\n//************************************* \\nvoid resortAndCheck(int totalDuplicates) {\\n    // sorts the new list, duplicateArray, which is full of new randoms\\n    quickSort2(0,totalDuplicates - 1);\\n    for (int n = 0; n < totalDuplicates; n++) {\\n        subjList[missingSpots[n]] = duplicateArray[n];\\n    }\\n    // here, we only need to call sort top and bottom\\n    // THESE FUNCTIONS ARE MADE BECAUSE THE COMPUTER CAN'T CHECK THE TOP AND BOTTOM ELEMENTS AGAINST THE ELEMENT ABOVE OR BELOW THEM\\n    // BECAUSE IT IS OUT OF THE ARRAY'S RANGE.  \\n    // we don't want to continuously check if every new value is the largest or smallest in the array because that wastes time.  \\n    // since the new random num list has been sorted, everything between the top and bottom elements will not try to access anything\\n    // outside the range of the array\\n    if (totalDuplicates == 1) {\\n        sortTop(1);\\n    } else if (totalDuplicates == 2) {\\n        // puts largest new randomly generated number in right spot in array\\n        sortTop(2);\\n        // puts smallest new randomly generated number in right spot in array\\n        sortBottom();\\n        // note that sort top must be called here again incase it bumps into sortBottom;\\n        sortTop(2);\\n    // must sort everything here\\n    } else if (totalDuplicates > 2) {\\n        sortTop(totalDuplicates);\\n        sortBottom();\\n        modifiedBubbleSort(totalDuplicates);\\n        sortTop(totalDuplicates);\\n        // for bottom value, if it is inserted too low, then it must be moved up.  However, because it is less than the\\n        // SECOND RANDOMLY generated newly inserted number, which is out of place itself, the sort bottom function will stop.  However,\\n        // the bottom element still might not be in the right spot.  thus we must recall the function\\n        sortBottom();\\n    }\\n    // display();\\n    totalDuplicates = 0;\\n    // checks for duplicates\\n    for (int k = 0; k < bugs; k++) {\\n        if (subjList[k] == subjList[(k + 1)%bugs]) {\\n            missingSpots[totalDuplicates] = k;\\n            duplicateArray[totalDuplicates] = rand()%population;\\n            totalDuplicates++;\\n        }\\n    }\\n    if (totalDuplicates == 0) {\\n        return;\\n    } else {\\n        resortAndCheck(totalDuplicates);\\n    }\\n}\\n//***********************************\\n\\n\\n//int argc, string argv[]\\n\\nint main() {\\n    // difference between two infected subject element numbers\\n    int difference;\\n    // number of people who have or know someone who has bedbugs\\n    int total = 0;\\n    // average % of population who knows someone with bedbugs or has bedbugs\\n    double runningAverage = 0;\\n    int totalDuplicates = 0;\\n    srand(time(NULL));\\n    for (int j = 1; j <= trials; j++) {\\n\\n        for (int y = 0; y < 300; y++) {\\n            duplicateArray[y] = population;\\n        }\\n        for (int i = 0; i < bugs; i++) {\\n            subjList[i] = (int) ((double) rand() / 6.58737315337);\\n        }\\n        // sorts list\\n        quickSort(0, bugs - 1);\\n        // checks for duplicates and assigns duplicates to duplicate array\\n        for (int k = 0; k < bugs - 1; k++) {\\n            if (subjList[k] == subjList[(k + 1)%bugs]) {\\n                missingSpots[totalDuplicates] = k;\\n                duplicateArray[totalDuplicates] = rand()%population;\\n                totalDuplicates++;\\n            }\\n        }\\n        resortAndCheck(totalDuplicates);\\n         // DO NOT DO THIS FOR THE LAST ARRAY ELEMENT, this totals the number of people who have/know someone who has bedbugs\\n        for (int k = 0; k < bugs - 1; k++) {\\n            difference = subjList[k + 1] - subjList[k];\\n            if (difference > numKnown) {  \\n                total = total + numKnown + 1;\\n            } else {\\n                total = total + difference;\\n                if (difference <= 0) {\\n                    printf(\\\"error, difference < 0\\\");\\n                    return 1;\\n                }\\n            }\\n        }\\n        totalDuplicates = 0;\\n        // also, this is to add to the total number of people who know someone with bedbugs or have bedbugs themselves.\\n        if (subjList[bugs - 1] + numKnown < population) {\\n            total = total + numKnown + 1;\\n        } else if (subjList[0] + population - subjList[bugs - 1] > numKnown) {\\n            total = total + numKnown + 1;\\n        } else {\\n            total = total + population - subjList[bugs - 1] + subjList[0];\\n        }\\n        runningAverage += (double) total / (double) population;\\n        printf(\\\"on this try, total = %i and running average = %f\\\\n\\\", total, runningAverage / (double) j);\\n        total = 0;\\n    }\\n    printf(\\\"\\\\n\\\");\\n    printline(50);\\n    printline(50);\\n    printline(50);\\n    printf(\\\"\\\\n\\\\n%f%% of people have or know someone who has bedbugs in a population of %i \\\\n with %i people infected\\\", runningAverage / (double) trials, population, bugs);\\n    printf(\\\" (%f%% of population or one out of every %f people)\\\\n\\\", (float) bugs / (float) population, (float) population / (float) bugs);\\n    // printf(\\\"if each knows %i people and is known by %i people\\\\n\\\\n\\\", numKnown, numKnown);\\n}\\n\\n\\n\"}],\"attrs\":[{\"text\":\"#include <stdio.h>\\n#include <stdbool.h>\\n#include <stdlib.h>\\n#include <cs50.h>\\n#include <math.h>\\n#include <time.h>\\n#include <string.h>\\n#define population 326000000\\n#define bugs 145173\\n#define numKnown 500\\n#define trials 600\\n\\n// list of element number of every infected person\\nint subjList[bugs];\\n// array to be sorted and first few elements added to subjList\\nint duplicateArray[500];\\n// keeps track of where the added numbers are\\nint missingSpots[1000];\\n\\nvoid printline(int count) {\\n   int i;\\n\\n   for(i = 0;i <count-1;i++) {\\n      printf(\\\"=\\\");\\n   }\\n\\n   printf(\\\"=\\\\n\\\");\\n}\\n//------------------------------------------------------------------------\\nvoid display() {\\n    int i;\\n    printf(\\\"[\\\");\\n    // navigate through all items \\n    for(i = 0;i<50;i++) {\\n        printf(\\\"%d \\\", subjList[i]);\\n        if (i%11 == 0) {\\n            printf(\\\"\\\\n\\\");\\n        }\\n    }\\n   printf(\\\"]\\\\n\\\");\\n}\\n\\nvoid swap(int num1, int num2) {\\n   int temp = subjList[num1];\\n   subjList[num1] = subjList[num2];\\n   subjList[num2] = temp;\\n}\\n\\nint partition(int left, int right, int pivot) {\\n   int leftPointer = left - 1;\\n   int rightPointer = right;\\n\\n   while(true) {\\n      while(subjList[++leftPointer] < pivot) {\\n         //do nothing\\n      }\\n\\n      while(rightPointer > 0 && subjList[--rightPointer] > pivot) {\\n         //do nothing\\n      }\\n\\n      if(leftPointer >= rightPointer) {\\n         break;\\n      } else {\\n        swap(leftPointer,rightPointer);\\n      }\\n   }\\n   swap(leftPointer,right);\\n   return leftPointer;\\n}\\n\\nvoid quickSort(int left, int right) {\\n   if(right-left <= 0) {\\n      return;   \\n   } else {\\n      int pivot = subjList[right];\\n      int partitionPoint = partition(left, right, pivot);\\n      quickSort(left,partitionPoint-1);\\n      quickSort(partitionPoint+1,right);\\n   }        \\n}\\n//------------------------------------------------------------------------------\\n\\nvoid swap2(int num1, int num2) {\\n   int temp = duplicateArray[num1];\\n   duplicateArray[num1] = duplicateArray[num2];\\n   duplicateArray[num2] = temp;\\n}\\n\\nint partition2(int left, int right, int pivot) {\\n   int leftPointer = left - 1;\\n   int rightPointer = right;\\n\\n   while(true) {\\n      while(duplicateArray[++leftPointer] < pivot) {\\n         //do nothing\\n      }\\n\\n      while(rightPointer > 0 && duplicateArray[--rightPointer] > pivot) {\\n         //do nothing\\n      }\\n\\n      if(leftPointer >= rightPointer) {\\n         break;\\n      } else {\\n        swap2(leftPointer,rightPointer);\\n      }\\n   }\\n   swap2(leftPointer,right);\\n   return leftPointer;\\n}\\n\\nvoid quickSort2(int left, int right) {\\n   if(right-left <= 0) {\\n      return;   \\n   } else {\\n      int pivot = duplicateArray[right];\\n      int partitionPoint = partition2(left, right, pivot);\\n      quickSort2(left,partitionPoint-1);\\n      quickSort2(partitionPoint+1,right);\\n   }        \\n}\\n\\n//---------------------------------------------------------------------------------------------\\n\\nvoid sortTop(int totalDuplicates) {\\n    int move = 0;\\n    // dont need to check if element was inserted into last place of subjArray cuz last element there is never deleted\\n    while (true) {\\n        move = 0;\\n        // stop trying to sort if we have moved the new number to the last (or unlikely case, first) place of subjArray\\n        if (missingSpots[totalDuplicates - 1] == bugs - 1 || missingSpots[totalDuplicates - 1] == 0) {\\n            return;\\n        } else if (subjList[missingSpots[totalDuplicates - 1]] > subjList[missingSpots[totalDuplicates - 1] + 1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(missingSpots[totalDuplicates - 1], missingSpots[totalDuplicates - 1] + 1);\\n            missingSpots[totalDuplicates - 1] += 1;\\n            move = 1;\\n        } else if (subjList[missingSpots[totalDuplicates - 1]] < subjList[missingSpots[totalDuplicates - 1] - 1]) {\\n            swap(missingSpots[totalDuplicates - 1], missingSpots[totalDuplicates - 1] - 1);\\n            missingSpots[totalDuplicates - 1] -= 1;\\n            move = 1;\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\nvoid sortBottom() {\\n    int move = 0;\\n    if (missingSpots[0] == 0) {\\n        if (subjList[0] > subjList[1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(0, 1);\\n            // moves the place of the thing in the missing spots array cuz we just moved it one in the master array\\n            missingSpots[0] += 1;\\n            move = 1;\\n        }\\n    }\\n    while (true) {\\n        move = 0;\\n        // stop trying to sort if we have moved the new number to the last place of subjArray\\n        if (missingSpots[0] == 0) {\\n            return;\\n        } else if (subjList[missingSpots[0]] > subjList[missingSpots[0] + 1]) {\\n            // swap the place in the array that has these two numbers because they're in the wrong order\\n            swap(missingSpots[0], missingSpots[0] + 1);\\n            missingSpots[0] += 1;\\n            move = 1;\\n        } else if (subjList[missingSpots[0]] < subjList[missingSpots[0] - 1]) {\\n            swap(missingSpots[0], missingSpots[0] - 1);\\n            missingSpots[0] -= 1;\\n            move = 1;\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\n// if two numbers are inserted next to eachother, this method still works\\nvoid modifiedBubbleSort(int totalDuplicates) {\\n    int move = 0;\\n    // dont need to check if element was inserted into last place of subjArray cuz last element there is never deleted\\n    while (true) {\\n        move = 0;\\n        for (int n = 1; n < totalDuplicates - 1; n++) {\\n            // stop trying to sort if we have moved the new number to the last (or unlikely case, first) place of subjArray\\n            if (missingSpots[n] == bugs - 1 || missingSpots[n] == 0) {\\n                return;\\n            } else if (subjList[missingSpots[n]] > subjList[missingSpots[n] + 1]) {\\n                // swap the place in the array that has these two numbers because they're in the wrong order\\n                swap(missingSpots[n], missingSpots[n] + 1);\\n                missingSpots[n] += 1;\\n                move = 1;\\n            } else if (subjList[missingSpots[n]] < subjList[missingSpots[n] - 1]) {\\n                swap(missingSpots[n], missingSpots[n] - 1);\\n                missingSpots[n] -= 1;\\n                move = 1;\\n            }\\n        }\\n        if (move == 0) {\\n            return;\\n        }\\n    }\\n}\\n\\n\\n// checks for duplicates within the master list, replaces them with other random numbers and re-sorts\\n//************************************* \\nvoid resortAndCheck(int totalDuplicates) {\\n    // sorts the new list, duplicateArray, which is full of new randoms\\n    quickSort2(0,totalDuplicates - 1);\\n    for (int n = 0; n < totalDuplicates; n++) {\\n        subjList[missingSpots[n]] = duplicateArray[n];\\n    }\\n    // here, we only need to call sort top and bottom\\n    // THESE FUNCTIONS ARE MADE BECAUSE THE COMPUTER CAN'T CHECK THE TOP AND BOTTOM ELEMENTS AGAINST THE ELEMENT ABOVE OR BELOW THEM\\n    // BECAUSE IT IS OUT OF THE ARRAY'S RANGE.  \\n    // we don't want to continuously check if every new value is the largest or smallest in the array because that wastes time.  \\n    // since the new random num list has been sorted, everything between the top and bottom elements will not try to access anything\\n    // outside the range of the array\\n    if (totalDuplicates == 1) {\\n        sortTop(1);\\n    } else if (totalDuplicates == 2) {\\n        // puts largest new randomly generated number in right spot in array\\n        sortTop(2);\\n        // puts smallest new randomly generated number in right spot in array\\n        sortBottom();\\n        // note that sort top must be called here again incase it bumps into sortBottom;\\n        sortTop(2);\\n    // must sort everything here\\n    } else if (totalDuplicates > 2) {\\n        sortTop(totalDuplicates);\\n        sortBottom();\\n        modifiedBubbleSort(totalDuplicates);\\n        sortTop(totalDuplicates);\\n        // for bottom value, if it is inserted too low, then it must be moved up.  However, because it is less than the\\n        // SECOND RANDOMLY generated newly inserted number, which is out of place itself, the sort bottom function will stop.  However,\\n        // the bottom element still might not be in the right spot.  thus we must recall the function\\n        sortBottom();\\n    }\\n    // display();\\n    totalDuplicates = 0;\\n    // checks for duplicates\\n    for (int k = 0; k < bugs; k++) {\\n        if (subjList[k] == subjList[(k + 1)%bugs]) {\\n            missingSpots[totalDuplicates] = k;\\n            duplicateArray[totalDuplicates] = rand()%population;\\n            totalDuplicates++;\\n        }\\n    }\\n    if (totalDuplicates == 0) {\\n        return;\\n    } else {\\n        resortAndCheck(totalDuplicates);\\n    }\\n}\\n//***********************************\\n\\n\\n//int argc, string argv[]\\n\\nint main() {\\n    // difference between two infected subject element numbers\\n    int difference;\\n    // number of people who have or know someone who has bedbugs\\n    int total = 0;\\n    // average % of population who knows someone with bedbugs or has bedbugs\\n    double runningAverage = 0;\\n    int totalDuplicates = 0;\\n    srand(time(NULL));\\n    for (int j = 1; j <= trials; j++) {\\n\\n        for (int y = 0; y < 300; y++) {\\n            duplicateArray[y] = population;\\n        }\\n        for (int i = 0; i < bugs; i++) {\\n            subjList[i] = (int) ((double) rand() / 6.58737315337);\\n        }\\n        // sorts list\\n        quickSort(0, bugs - 1);\\n        // checks for duplicates and assigns duplicates to duplicate array\\n        for (int k = 0; k < bugs - 1; k++) {\\n            if (subjList[k] == subjList[(k + 1)%bugs]) {\\n                missingSpots[totalDuplicates] = k;\\n                duplicateArray[totalDuplicates] = rand()%population;\\n                totalDuplicates++;\\n            }\\n        }\\n        resortAndCheck(totalDuplicates);\\n         // DO NOT DO THIS FOR THE LAST ARRAY ELEMENT, this totals the number of people who have/know someone who has bedbugs\\n        for (int k = 0; k < bugs - 1; k++) {\\n            difference = subjList[k + 1] - subjList[k];\\n            if (difference > numKnown) {  \\n                total = total + numKnown + 1;\\n            } else {\\n                total = total + difference;\\n                if (difference <= 0) {\\n                    printf(\\\"error, difference < 0\\\");\\n                    return 1;\\n                }\\n            }\\n        }\\n        totalDuplicates = 0;\\n        // also, this is to add to the total number of people who know someone with bedbugs or have bedbugs themselves.\\n        if (subjList[bugs - 1] + numKnown < population) {\\n            total = total + numKnown + 1;\\n        } else if (subjList[0] + population - subjList[bugs - 1] > numKnown) {\\n            total = total + numKnown + 1;\\n        } else {\\n            total = total + population - subjList[bugs - 1] + subjList[0];\\n        }\\n        runningAverage += (double) total / (double) population;\\n        printf(\\\"on this try, total = %i and running average = %f\\\\n\\\", total, runningAverage / (double) j);\\n        total = 0;\\n    }\\n    printf(\\\"\\\\n\\\");\\n    printline(50);\\n    printline(50);\\n    printline(50);\\n    printf(\\\"\\\\n\\\\n%f%% of people have or know someone who has bedbugs in a population of %i \\\\n with %i people infected\\\", runningAverage / (double) trials, population, bugs);\\n    printf(\\\" (%f%% of population or one out of every %f people)\\\\n\\\", (float) bugs / (float) population, (float) population / (float) bugs);\\n    // printf(\\\"if each knows %i people and is known by %i people\\\\n\\\\n\\\", numKnown, numKnown);\\n}\\n\",\"language\":null}]},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"\"}]},{\"type\":\"text\",\"text\":\"\\n\\n                                    \\n                                \\n                            \"}]}","reactions":[2,0,0,0],"comments":[]}]},{"source":"public/brilliantexport/problems/../problems/1-inch-x-1-inch-tiles/1-inch-x-1-inch-tiles.html","category":"Probability","level":1,"title":"1 inch x 1 inch tiles","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Each letter in the word \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\"BRILLIANT\\\"\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" were written in \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"1\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" inch by \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"1\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" inch tiles. These tiles were put in a box. If two tiles are drawn at random without replacement, what is the probability that the two letters are the same letters? The answer is in the form \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\dfrac{x}{y}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", where \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"x\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" and \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"y\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" are positive co-prime integers. \"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Find \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"3x^{321}+3y^3\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]}]}","answers":[{"correct":true,"text":"17499"}],"author":{"profile":"https://brilliant.org/profile/marvin-st342q/","name":"Marvin Kalngan","age":38,"location":"Philippines"},"discussion":[{"author":{"avatar":"../../brioche/avatars-2/resized/45/7c908f6f2b7fecac94df3e6bdf494088.57aa43306d-1u6pESi4ZY.jpg?width=45","profile":"https://brilliant.org/profile/vinayak-zvt5t4/","name":"Vinayak Srivastava"},"date":"May 13, 2020, 3:12 a.m.","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n                                \\n                                \\n                                \\n                                    \\n                                        \"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"There are \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"9\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" letters in the word \"},{\"type\":\"text\",\"text\":\"\\\"BRILLIANT\\\"\",\"marks\":[{\"type\":\"bold\"}]},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Two letters, \"},{\"type\":\"text\",\"text\":\"\\\"I\\\"\",\"marks\":[{\"type\":\"bold\"}]},{\"type\":\"text\",\"text\":\" and \"},{\"type\":\"text\",\"text\":\"\\\"L\\\"\",\"marks\":[{\"type\":\"bold\"}]},{\"type\":\"text\",\"text\":\" can be picked twice. So, the number of favorable outcomes is \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"2\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"The total number of ways of picking two letters from the word \"},{\"type\":\"text\",\"text\":\"\\\"BRILLIANT\\\"\",\"marks\":[{\"type\":\"bold\"}]},{\"type\":\"text\",\"text\":\" are  \"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\Large{9 \\\\choose 2}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=\"}],\"attrs\":{\"inline\":true}},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\dfrac{9\\\\cdot8}{2}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=36\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"So the probability that the two letters are the same letters is Number of favorable outcomes\"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\div\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\"Total number of Outcomes\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=\"}],\"attrs\":{\"inline\":true}},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\dfrac{2}{36}\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=\\\\dfrac{1}{18}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"text\",\"text\":\"Since \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"1\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" and \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"18\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" are co-prime,\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\dfrac{x}{y}=\\\\dfrac{1}{18}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\implies x=1, y=18\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\".\"}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"3x^{321} +3y^3\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=3\\\\cdot1^{321}+3\\\\cdot18^3\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=3\\\\cdot1 +3\\\\cdot5832\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=3 + 17496\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n\"},{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"=\\\\boxed{17499}\"}],\"attrs\":{\"inline\":true}}]},{\"type\":\"text\",\"text\":\"\\n\\n                                    \\n                                \\n                            \"}]}","reactions":[0,0,1,0],"comments":[]}]},{"source":"public/brilliantexport/problems/../problems/1-incoming-2/1-incoming-2.html","category":"Geometry","level":2,"title":"(1) - Incoming","body":"{\"type\":\"doc\",\"content\":[{\"type\":\"paragraph\",\"content\":[{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{ABC}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" is a triangle such that \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\widehat{\\\\text{CAB}} = 90^\\\\circ\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\widehat{\\\\text{ABC}} = \\\\alpha\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\", \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\widehat{\\\\text{BCA}} = \\\\alpha + \\\\beta\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" (\"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\beta < \\\\alpha\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\"). \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{D}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" and \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{E}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" are two points on line segment \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{AB}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" such that \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\widehat{\\\\text{ACD}} = \\\\widehat{\\\\text{BCE}} = \\\\beta\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" and \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\text{BE} = 2\\\\text{AD}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\". What is the measurement of \"},{\"type\":\"katex\",\"content\":[{\"type\":\"text\",\"text\":\"\\\\widehat{\\\\text{BCA}}\"}],\"attrs\":{\"inline\":true}},{\"type\":\"text\",\"text\":\" in degrees?\"}]}]}","answers":[{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n75\\n\\n\"}]}"},{"correct":true,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n50\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n60\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n80\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n65\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n70\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n85\\n\\n\"}]}"},{"correct":false,"text":"{\"type\":\"doc\",\"content\":[{\"type\":\"text\",\"text\":\"\\n\\n\\n55\\n\\n\"}]}"}],"author":{"profile":"https://brilliant.org/profile/thanh-at-kgl1kz/","name":"Thành Đạt Lê","age":17,"location":"Singapore"},"discussion":[]}]